<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ü§ñ LiveKit Bot Spawner</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
      color: white;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border-radius: 16px;
      padding: 32px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }
    
    h1 {
      font-size: 32px;
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    
    .subtitle {
      color: rgba(255, 255, 255, 0.8);
      margin-bottom: 32px;
    }
    
    .form-group {
      margin-bottom: 20px;
    }
    
    label {
      display: block;
      font-weight: 600;
      margin-bottom: 8px;
      font-size: 14px;
    }
    
    input, select {
      width: 100%;
      padding: 12px;
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      background: rgba(255, 255, 255, 0.9);
      color: #333;
      font-size: 16px;
      transition: all 0.3s;
    }
    
    input:focus, select:focus {
      outline: none;
      border-color: #764ba2;
      box-shadow: 0 0 0 3px rgba(118, 75, 162, 0.2);
    }
    
    button {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      border: none;
      padding: 14px 32px;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      font-size: 16px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
      width: 100%;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(245, 87, 108, 0.4);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }
    
    .status {
      margin-top: 24px;
      padding: 16px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .status-line {
      margin: 4px 0;
      padding: 4px;
      border-left: 3px solid transparent;
    }
    
    .status-line.success {
      border-left-color: #10b981;
    }
    
    .status-line.error {
      border-left-color: #ef4444;
    }
    
    .status-line.info {
      border-left-color: #3b82f6;
    }
    
    .bot-count {
      display: inline-block;
      background: rgba(16, 185, 129, 0.2);
      border: 2px solid #10b981;
      border-radius: 8px;
      padding: 8px 16px;
      margin-top: 16px;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>
      <span>ü§ñ</span>
      LiveKit Bot Spawner
    </h1>
    <p class="subtitle">Spawn multiple fake participants for load testing</p>
    
    <div class="form-group">
      <label for="roomCode">Room Code</label>
      <input type="text" id="roomCode" placeholder="Y2B-SY4Q-A2T" required>
    </div>
    
    <div class="form-group">
      <label for="numBots">Number of Bots (1-50)</label>
      <input type="number" id="numBots" min="1" max="50" value="5" required>
    </div>
    
    <div class="form-group">
      <label for="audioPercent">Bots with Audio Enabled (%)</label>
      <input type="number" id="audioPercent" min="0" max="100" value="70">
    </div>
    
    <div class="form-group">
      <label for="videoPercent">Bots with Video Enabled (%)</label>
      <input type="number" id="videoPercent" min="0" max="100" value="70">
    </div>
    
    <button id="spawnBtn" onclick="startSpawning()">
      üöÄ Spawn Bots
    </button>
    
    <button id="stopBtn" onclick="stopAllBots()" style="background: linear-gradient(135deg, #ff6b6b 0%, #c92a2a 100%); display: none; margin-top: 12px;">
      ‚èπÔ∏è Stop All Bots
    </button>
    
    <div id="botCount" class="bot-count" style="display: none;">
      Active Bots: <span id="activeBotCount">0</span>
    </div>
    
    <div class="status" id="status"></div>
  </div>

  <!-- Load LiveKit Client from CDN (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/livekit-client@2.5.8/dist/livekit-client.umd.min.js"></script>
  <script>
    const LIVEKIT_URL = 'wss://elearning-microservice-98bdertb.livekit.cloud';
    const LIVEKIT_API_KEY = 'APIw58QnxLKZhHz';
    const LIVEKIT_API_SECRET = 'efMRFX9tmBWDrGUkvO9WKp3jh2pVJ6UlVWXp3gJZ3rB';
    
    let bots = [];
    let activeBotCount = 0;
    
    function log(message, type = 'info') {
      const statusDiv = document.getElementById('status');
      const line = document.createElement('div');
      line.className = `status-line ${type}`;
      line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      statusDiv.appendChild(line);
      statusDiv.scrollTop = statusDiv.scrollHeight;
    }
    
    function updateBotCount() {
      document.getElementById('activeBotCount').textContent = activeBotCount;
      document.getElementById('botCount').style.display = activeBotCount > 0 ? 'block' : 'none';
    }
    
    // Generate LiveKit token directly in browser
    function generateToken(roomName, botIdentity, botName) {
      const now = Math.floor(Date.now() / 1000);
      const exp = now + 86400; // 24 hours
      
      const payload = {
        exp: exp,
        iss: LIVEKIT_API_KEY,
        nbf: now,
        sub: botIdentity,
        name: botName,
        video: {
          room: roomName,
          roomJoin: true,
          canPublish: true,
          canSubscribe: true,
          canPublishData: true,
        },
        metadata: JSON.stringify({
          isBot: true,
          botType: 'test',
          createdAt: new Date().toISOString(),
        }),
      };
      
      // Encode to base64url manually (simple implementation)
      function base64UrlEncode(str) {
        const base64 = btoa(str);
        return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
      }
      
      // Create JWT header
      const header = {
        alg: 'HS256',
        typ: 'JWT'
      };
      
      const encodedHeader = base64UrlEncode(JSON.stringify(header));
      const encodedPayload = base64UrlEncode(JSON.stringify(payload));
      
      // Create signature using Web Crypto API
      const message = encodedHeader + '.' + encodedPayload;
      
      // Use HMAC SHA256
      return crypto.subtle.importKey(
        'raw',
        new TextEncoder().encode(LIVEKIT_API_SECRET),
        { name: 'HMAC', hash: 'SHA-256' },
        false,
        ['sign']
      ).then(key => {
        return crypto.subtle.sign('HMAC', key, new TextEncoder().encode(message));
      }).then(signature => {
        const base64Signature = btoa(String.fromCharCode(...new Uint8Array(signature)));
        const urlSafeSignature = base64Signature.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
        return message + '.' + urlSafeSignature;
      });
    }
    
    function createFakeVideoTrack(botName, color) {
      const canvas = document.createElement('canvas');
      canvas.width = 640;
      canvas.height = 480;
      const ctx = canvas.getContext('2d');
      
      function animate() {
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.font = 'bold 120px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = 'white';
        ctx.fillText('ü§ñ', canvas.width / 2, canvas.height / 2 - 40);
        
        ctx.font = 'bold 36px Arial';
        ctx.fillText(botName, canvas.width / 2, canvas.height / 2 + 60);
        
        ctx.font = '20px monospace';
        ctx.fillText(new Date().toLocaleTimeString(), canvas.width / 2, canvas.height - 40);
        
        requestAnimationFrame(animate);
      }
      animate();
      
      return canvas.captureStream(30).getVideoTracks()[0];
    }
    
    function createFakeAudioTrack() {
      const audioContext = new AudioContext();
      const oscillator = audioContext.createOscillator();
      const destination = audioContext.createMediaStreamDestination();
      
      oscillator.frequency.value = 0; // Silent
      oscillator.connect(destination);
      oscillator.start();
      
      return destination.stream.getAudioTracks()[0];
    }
    
    function getRandomColor() {
      const colors = ['#1e3a8a', '#7c2d12', '#166534', '#86198f', '#be123c', '#0f766e'];
      return colors[Math.floor(Math.random() * colors.length)];
    }
    
    async function spawnBot(roomCode, botIndex, enableAudio, enableVideo) {
      const botName = `TestBot-${botIndex}`;
      const botIdentity = `bot-${botIndex}-${Date.now()}`;
      
      try {
        const token = await generateToken(roomCode, botIdentity, botName);
        
        log(`üîó ${botName}: Connecting...`, 'info');
        
        const LiveKit = window.LivekitClient || window.livekit;
        if (!LiveKit || !LiveKit.Room) {
          throw new Error('LiveKit library not loaded. Please refresh (Ctrl+F5).');
        }

        const room = new LiveKit.Room();
        
        await room.connect(LIVEKIT_URL, token, {
          autoSubscribe: true,
        });

        // Metadata is already embedded in the JWT token.
        log(`‚úÖ ${botName}: Connected!`, 'success');
        
        // Publish tracks
        if (enableVideo) {
          try {
            const videoTrack = createFakeVideoTrack(botName, getRandomColor());
            await room.localParticipant.publishTrack(videoTrack, {
              name: 'camera',
              source: LiveKit.Track.Source.Camera,
            });
            log(`üìπ ${botName}: Video published`, 'success');
          } catch (err) {
            log(`‚ùå ${botName}: Video error - ${err?.message ?? err}`, 'error');
          }
        } else {
          log(`üìπ ${botName}: Video disabled`, 'info');
        }
        
        if (enableAudio) {
          try {
            const audioTrack = createFakeAudioTrack();
            await room.localParticipant.publishTrack(audioTrack, {
              name: 'microphone',
              source: LiveKit.Track.Source.Microphone,
            });
            log(`üé§ ${botName}: Audio published`, 'success');
          } catch (err) {
            log(`‚ùå ${botName}: Audio error - ${err?.message ?? err}`, 'error');
          }
        } else {
          log(`üé§ ${botName}: Audio disabled`, 'info');
        }
        
        activeBotCount++;
        updateBotCount();
        
        // Random actions
        const interval = setInterval(() => {
          if (room.state !== 'connected') {
            clearInterval(interval);
            return;
          }
          
          const action = Math.floor(Math.random() * 4);
          if (action === 0 && enableAudio) {
            const isMuted = Math.random() > 0.5;
            room.localParticipant.setMicrophoneEnabled(!isMuted);
            log(`üé§ ${botName}: ${isMuted ? 'Muted' : 'Unmuted'}`, 'info');
          } else if (action === 1 && enableVideo) {
            const isEnabled = Math.random() > 0.5;
            room.localParticipant.setCameraEnabled(isEnabled);
            log(`üìπ ${botName}: Camera ${isEnabled ? 'ON' : 'OFF'}`, 'info');
          }
        }, 15000 + Math.random() * 15000);
        
        bots.push({ room, botName, interval });
        
      } catch (error) {
        log(`‚ùå ${botName}: ${error.message}`, 'error');
      }
    }
    
    async function startSpawning() {
      const roomCode = document.getElementById('roomCode').value.trim();
      const numBots = parseInt(document.getElementById('numBots').value);
      const audioPercent = parseInt(document.getElementById('audioPercent').value) / 100;
      const videoPercent = parseInt(document.getElementById('videoPercent').value) / 100;
      
      if (!roomCode) {
        alert('Please enter a room code');
        return;
      }
      
      if (isNaN(numBots) || numBots < 1 || numBots > 50) {
        alert('Number of bots must be between 1 and 50');
        return;
      }
      
      document.getElementById('spawnBtn').disabled = true;
      document.getElementById('stopBtn').style.display = 'block';
      document.getElementById('status').innerHTML = '';
      
      log(`üöÄ Starting to spawn ${numBots} bots...`, 'info');
      
      for (let i = 1; i <= numBots; i++) {
        const enableAudio = Math.random() < audioPercent;
        const enableVideo = Math.random() < videoPercent;
        
        await spawnBot(roomCode, i, enableAudio, enableVideo);
        
        // Delay between bots
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
      
      log(`‚úÖ All ${numBots} bots spawned!`, 'success');
      document.getElementById('spawnBtn').disabled = false;
    }
    
    function stopAllBots() {
      log(`‚èπÔ∏è Stopping all ${bots.length} bots...`, 'info');
      
      bots.forEach(({ room, botName, interval }) => {
        clearInterval(interval);
        room.disconnect();
        log(`üëã ${botName}: Disconnected`, 'info');
      });
      
      bots = [];
      activeBotCount = 0;
      updateBotCount();
      
      document.getElementById('stopBtn').style.display = 'none';
      log(`‚úÖ All bots stopped`, 'success');
    }
  </script>
</body>
</html>
